/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package biocomputation;


import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.*;

/**
 *
 * @author Callum
 */
public class classification {

    /**
     * @param args the command line arguments
     */
    //Global integers leave em alone
    static final int Pop = 200;//number of individuals in a given population
    static final int N = 70;//Number of Genes
    static final int mP = 10;//Mutation Probablity
    static final int generations = 400; //Number of generations/iterations
    static final int row32L = 5;//Number of bits located in the input variable component of a data1 row
    static final int row64L = 6;//^^ but six and data2
    static final int indoRules = 10;//Number of 'rules' generated by each individual in the population.
    static final int indoRules64 = 12;
    
    public static String enhance = "src/biocomputation/output";

    public static void main(String[] args) throws UnsupportedEncodingException, IOException {
        // TODO code application logic here

        row32[] input = new row32[32];
        row64[] input64 = new row64[64];
        row2000[] input2000 = new row2000[2000];

        getData(input, input64, input2000);

//------------------------------------------------------------------------------
//----- Genetic Algorithm Start
///-----------------------------------------------------------------------------
        System.out.println("hey");

        int i, j, y, g = 0;

        //Running totals for the given fitness of a population. I am only storing
        //the first and final fitness totals to draw a contrast/illustrate how well
        //the selection process works.
        individual[] population = new individual[Pop];
        individual[] offspring = new individual[Pop];
        individual[] crossoverKids = new individual[Pop];
        individual fittestIndividual = new individual();
        int highestFitness = 0;

        for (g = 0; g < generations; g++) {

            int initialFT = 0;
            int currentFT = 0;
            int offspringFT = 0;
            int averageFitness = 0;
            int lowestFitness = 2000;

            if (g == 0) {
                //GENERATE A POPULATION
                //Create a new array of individuals called population. This is then
                //populated in the nested loops below.

                for (i = 0; i < Pop; i++) {
                    //Create a new individual at the start of each initial loop. This individuals
                    //genes are then randomly assigned in the nested loop, either to 1 or 0
                    population[i] = new individual();

                    for (j = 0; j < N; j++) {

                        int k = random();
                        population[i].setGenes(j, k);

                    }
                    population[i].setFitness(0);
                }

                //This loop assesses the 'fitness' of each individual population. This is measured
                //by the total number of 1's vs 0's. The more 1's, the higher a given individuals fitness
                for (i = 0; i < Pop; i++) {

                    individual rando = population[i];
                    population[i].fitness = getFunked32(rando, input);
                    initialFT += population[i].getFitness();

                }

                System.out.println("--------------------------------------------------------------------------------------");
                System.out.println("Generation Number " + g + ". The Population size is " + Pop + " and the chromosome length is " + N);
                System.out.println("The total fitness of the initial population is: " + initialFT);
            } else if (g != 0) {
                population = crossoverKids;
                System.out.println("--------------------------------------------------------------------------------------");
                System.out.println("Generation Number " + g + ". The Population size is " + Pop + " and the chromosome length is " + N);
                // System.out.println("The total fitness of the initial population is: " + initialFT);

            }
            //----------------------------------
            //TOURNAMENT SELECTION

            //This is tournament selection. Two individuals are chosen at near-random to
            // go head to head. The winner, or the individuals with the highest fitness ranking
            // is copied into an offspring array. This is done until the size of the offspring array
            //matches that of the original population array. Previously did this in a function/method
            //but it didn't work so now I'm scared
            for (i = 0; i < Pop; i++) {
                int parent1 = getRandomNumberInRange(0, Pop - 1);
                int parent2 = getRandomNumberInRange(0, Pop - 1);

                int p1Fitness = population[parent1].getFitness();
                int p2Fitness = population[parent2].getFitness();

                if (p1Fitness >= p2Fitness) {
                    offspring[i] = population[parent1];
                } else {
                    offspring[i] = population[parent2];
                }
            }
            //---------------------------------------------

            //Check the fitness after tournament selection
            for (i = 0; i < Pop; i++) {
                offspring[i].fitness = getFunked32(offspring[i], input);
                currentFT += offspring[i].getFitness();

            }

            System.out.println("The total fitness of the offspring population after tournament selection is is: " + currentFT);

            //------------------------------------------------
            //CROSSOVER
            //
            //Crossing over pairs of individuals; selecting a random point,
            //and swapping the genes of the two individuals after that point
            // ie point = 4, the first 4 genes of each individual stay the same but
            //those thereafter are swapped.
            crossoverKids = crossoverExecute(crossoverKids, offspring);

            //--------------------------------
            //MUTATION
            //Each gene, when passed in to the mutation method has a 1/pM chance of
            //mutating. The mutated gene replaces the original gene. pM is set to a value
            //somewhere between the length of the chromosome of an individual (sequence of genes)
            //and the size of the population. Initially, these were both ten.
            for (int x = 0; x < Pop; x++) {
                int[] genes = crossoverKids[x].genes;
                int[] newGenes = new int[genes.length];

                newGenes = bitwiseMutation(genes);
                for (y = 0; y < genes.length; y++) {
                    crossoverKids[x].setGenes(y, newGenes[y]);
                }
            }
            //----------------------------------------------
            //FITNESS REASSESSMENT

            for (i = 0; i < Pop; i++) {
                crossoverKids[i].fitness = getFunked32(crossoverKids[i], input);
                //Check if the current individual is the fittest.
                if (highestFitness < crossoverKids[i].getFitness()) {
                    highestFitness = crossoverKids[i].getFitness();
                    fittestIndividual = crossoverKids[i];
                }
                else if (lowestFitness > offspring[i].getFitness()){
                    lowestFitness = offspring[i].getFitness();
                     
                }
                offspringFT += crossoverKids[i].getFitness();

            }
            averageFitness = offspringFT / Pop;
            //System.out.println("");
            System.out.println("The total fitness of the offspring population after crossover and mutation is: " + offspringFT);
            System.out.println("The highest fitness value of any individual in the offspring population is : " + highestFitness);
            System.out.println("The average fitness of the offspring population after crossover and mutation is: " + averageFitness);
            System.out.println("The lowest fitness of the offspring population after crossover and mutation is: " + lowestFitness);
            System.out.println("--------------------------------------------------------------------------------------");
            System.out.println("");

              writeFittest("1", generations, highestFitness, g, Pop, N);
            writeAverage("1", generations, averageFitness, g, Pop, N);
            writeLowest("1", generations, lowestFitness, g, Pop, N);
            //---------------------------------------------------   

            //---------------------------------------------------   
            
        }//End of big for(g=0.. loop
        System.out.println("The highest fitness of any individual in any generation is: " + fittestIndividual.getFitness() + "\n");
        System.out.println("The fittest individuals array contents : \n");
        
        
     
        
      

    }

    //----------------------------------------------------------------------------
    //GENETIC ALGORITHM METHODS
    //----------------------------------------------------------------------------
    //Bitwise Mutation Method
    public static int[] bitwiseMutation(int[] genes) {

        //the luck variable is used as the probability,
        //it will be a number between 0 - 10, and if that number is 7
        // the gene at position y is mutated. The value of luck changes
        //with each iteration.
        int length = genes.length;

        int[] mutantGenes = new int[length];

    for (int y = 1; y < length; y++) {
            int luck = getRandomNumberInRange(0, N);
            if (luck == 7) {
                //Mutate(invert) the genes if luck is a lady
                
                switch (genes[y]) {
                    case 0:
                        int luck2 = random();
                        if (luck2 == 1) {
                            mutantGenes[y-1] = 1;
                        } else {
                            if (!waitNooo(y)) {
                                mutantGenes[y - 1] = 2;
                            } else {
                                mutantGenes[y - 1] = 1;
                            }
                        }   break;
                    case 1:
                        int luck3 = random();
                        if (luck3 == 1) {
                            mutantGenes[y-1] = 0;
                        } else {
                            if (!waitNooo(y)) {
                                mutantGenes[y-1] = 2;
                            }else {
                                mutantGenes[y-1] = 0;
                            }
                            
                        }   break;
                    default:
                        int luck4 = random();
                        if (luck4 == 1) {
                            mutantGenes[y-1] = 0;
                        } else {
                            mutantGenes[y-1] = 1;
                        }   break;
                }
            } //if luck is not a lady, the genes don't change, so assign
            //the original gene value at position y  to the 
            // corresponding position in the return array.
            else {
                mutantGenes[y-1] = genes[y-1];
            }
        }
        return mutantGenes;

    }

    
    public static boolean waitNooo(int y){
    
        return y % 6 == 0;
    
    }
    
    
    
//Get a random 1 or 0 
    public static int random() {
        if (Math.random() < 0.5) {
            return 1;
        }
        return 0;
    }

//Get a random number in a given range/this comment is
//very necessary despite the methods very literal name
    private static int getRandomNumberInRange(int min, int max) {

        if (min >= max) {
            throw new IllegalArgumentException("max must be greater than min");
        }

        Random r = new Random();
        return r.nextInt((max - min) + 1) + min;
    }

//-------------------------------------
//Crossover Method
     private static int[][] crossover(int[] parent1, int[] parent2) {

        int[][] children = new int[2][N];
        int crossPoint = getRandomNumberInRange(0, N);

        int[] temp = parent1.clone();
        for (int i = crossPoint; i < N; i++) {
            parent1[i] = parent2[i];
            parent2[i] = temp[i];
        }

        children[0] = parent1;
        children[1] = parent2;

        return children;
    }
//-----------------------------------------------------
//FITNESS FUNCTIONS
    private static int getFunked32(individual rando, row32[] scranko) {
        int sFitness = 0;
        int g = 0;
        individual nrando = rando;
        row32[] rules = new row32[indoRules];

        //feed in the genes to make some rules
        for (int i = 0; i < indoRules; i++) {
            int[] tempArray = new int[5];
            int pv = 0;
            for (int j = 0; j < 6; j++) {

                if (j == 5) {
                    pv = nrando.genes[g++];

                } else {
                    tempArray[j] = nrando.genes[g++];

                }
            }
            rules[i] = new row32(tempArray, pv);
        }

        //print loop
        //To test if the rule array has been populated correctly from the individual
        /*   for(int i = 0;i < rules.length;i++){
          System.out.println(Arrays.toString(rules[i].var) + " " + rules[i].predicted);
      }*/
        for (int i = 0; i < scranko.length; i++) {
            for (int j = 0; j < indoRules; j++) {

                if (wildling(rules[j].var, scranko[i].var)) {
                    if (scranko[i].getPredicted() == rules[j].getPredicted()) {
                        sFitness++;
                    }
                        break;
                }

                

            }
        }

        return sFitness;
    }

    private static int getFunked64(individual rando, row64[] inputData64) {
        int sFitness = 0;
        int g = 0;
        individual nrando = rando;
        row64[] rules = new row64[indoRules64];

        //feed in the genes to make some rules
        for (int i = 0; i < indoRules64; i++) {
            int[] tempArray = new int[6];
            int pv = 0;
            for (int j = 0; j < 7; j++) {

                if (j == 6) {
                    pv = nrando.genes[g++];

                } else {
                    tempArray[j] = nrando.genes[g++];

                }
            }
            rules[i] = new row64(tempArray, pv);
        }

        //print loop
        //To test if the rule array has been populated correctly from the individual
        /*  for(int i = 0;i < rules.length;i++){
          System.out.println(Arrays.toString(rules[i].var) + " " + rules[i].predicted);
      }*/
        for (int i = 0; i < inputData64.length; i++) {
            for (int j = 0; j < indoRules64; j++) {
                if (Arrays.equals(rules[j].var, inputData64[i].var)) {//if the contents of each array i.e. the rules match
                    if (inputData64[i].getPredicted() == rules[j].getPredicted()) {
                        sFitness++;
                    }
                    break;
                }
            }
        }

        return sFitness;
    }

    //Method to read in data and populate arrays with the data
    public static void getData(row32[] input, row64[] input64, row2000[] input2000) {
        //Read in the text files and turn the variables and predicted variable into
        //attributes of individual objects
        Scanner sc32 = new Scanner(classification.class.getResourceAsStream("data1.txt"));
        for (int i = 0; i < 32; i++) {

            String line = sc32.nextLine();
            String[] parts = line.split(" ");
            int[] parsed = new int[row32L];

            //convert the input variable from a string to an integer
            for (int x = 0; x < row32L; x++) {
                parsed[x] = Integer.parseInt(String.valueOf(parts[0].charAt(x)));
            }

            input[i] = new row32(parsed, Integer.parseInt(parts[1]));
            System.out.println(Arrays.toString(input[i].var) + " " + input[i].predicted);

        }

        // 64 read in
        Scanner sc64 = new Scanner(classification.class.getResourceAsStream("data2.txt"));
        for (int i = 0; i < 64; i++) {
            String line = sc64.nextLine();
            String[] parts = line.split(" ");

            int[] parsed = new int[row64L];

            //convert the input variable from a string to an integer
            for (int x = 0; x < row64L; x++) {
                parsed[x] = Integer.parseInt(String.valueOf(parts[0].charAt(x)));
            }

            input64[i] = new row64(parsed, Integer.parseInt(parts[1]));
            // System.out.println(Arrays.toString(input64[i].var) + " " + input64[i].predicted);
        }

        //2000 read in
        

    }

    public static individual[] crossoverExecute(individual[] crossy, individual[] offspring) {
        for (int i = 0; i < Pop; i++) {
            crossy[i] = new individual();
        }

        for (int i = 0; i < Pop; i += 2) {

            //Retrieve arrays of genes so as to pass them into the crossover method
            int[] p0 = offspring[i].genes;
            int[] p1 = offspring[i + 1].genes;

            int[][] kids = crossover(p0, p1);

            //The tails have been swapped, new children formed
            crossy[i].genes = kids[0];
            crossy[i + 1].genes = kids[1];

        }
        return crossy;
    }

    public static boolean wildling(int[] a, int[] b) {

        int length = a.length;

        int count = 0;

        for (int i = 0; i < length; i++) {
            if (a[i] == b[i] || a[i] == 2) {
                count++;
            }
        }

        return count == 5;
    }
    
    


    public static boolean match(char[] a, char[] b) {
        int length = a.length;
        int count = 0;

        for (int i = 0; i < length; i++) {
            if (a[i] == b[i] || b[i] == '2') {
                count++;
            }
        }

        return count == 5;
    }
    
    
    
    
    
   public static void writeFittest(String file, int genNum, int fittestIndividual, int numGen, int popSize, int numGenes) throws IOException {
        String suffix = numGen + "-" + popSize + "-" + numGenes + ".csv";
        
        if("1".equals(file)){
            file = enhance + "data32-HFIT" + suffix;
        }
        else if("2".equals(file)){
            file = enhance + "data64-HFIT" + suffix;
        }
        else if("3".equals(file)){
            file = enhance + "data2000-HFIT" + suffix;
        }
 
        String str = String.valueOf(genNum) + "," + String.valueOf(fittestIndividual);
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, true))) {
            writer.append(str + "\n");
        }
    }
       public static void writeAverage(String file, int genNum, int averageFitness, int numGen, int popSize, int numGenes) throws IOException {
        String suffix = numGen + "-" + popSize + "-" + numGenes + ".csv";
        
        if("1".equals(file)){
            file = enhance + "data32-AVFIT" + suffix;
        }
        else if("2".equals(file)){
            file = enhance + "data64-AVFIT" + suffix;
        }
        else if("3".equals(file)){
            file = enhance + "data2000-AVFIT" + suffix;
        }
 
        String str = String.valueOf(genNum) + "," + String.valueOf(averageFitness);
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, true))) {
            writer.append(str + "\n");
        }
    }
        public static void writeLowest(String file, int genNum, int lowestFitness, int numGen, int popSize, int numGenes) throws IOException {
        String suffix = numGen + "-" + popSize + "-" + numGenes + ".csv";
        
        if("1".equals(file)){
            file = enhance + "data32-LOFIT" + suffix;
        }
        else if("2".equals(file)){
            file = enhance + "data64-LOFIT" + suffix;
        }
        else if("3".equals(file)){
            file = enhance + "data2000-LOFIT" + suffix;
        }
 
        String str = String.valueOf(genNum) + "," + String.valueOf(lowestFitness);
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, true))) {
            writer.append(str + "\n");
        }
    }

      
  
    
}
