package biocomputation;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.*;
import static jdk.nashorn.internal.objects.NativeMath.round;

public class classification2000 {

    //Global integers leave em alone
    static int numberofNines = 0;
    static final int pop = 100;//number of individuals in a given population
    static final int N = 130;//Number of Genes
    static final int generations = 1000; //Number of generations/iterations
    static final int row32L = 5;//Number of bits located in the input variable component of a data1 row
    static final int row64L = 6;//^^ but six and data2
    static final int r2l = 12;//^^data3
    static final int indoRules = 10;//Number of 'rules' generated by each individual in the population.

    static individual2000[] population = new individual2000[pop];
    static individual2000[] offspring = new individual2000[pop];
    static individual2000 fittest = new individual2000();
    static   individual2000 worst = new individual2000 ();
    static int highestFitness = 0;
    public static String enhance = "src/biocomputation/output";
    
    public static void main(String[] args) throws UnsupportedEncodingException, FileNotFoundException, IOException {

        row2000[][] data = getData2000();      
        row2000[] trainingData = data[0];
        row2000[] testData = data[1];

        for (int g = 0; g < generations; g++) {

            int initialFT = 0;
            int currentFT = 0;
            int offspringFT = 0;
            int averageFitness = 0;
            int lowestFitness = 2000;
          
            if (g == 0) {
                //GENERATE A POPULATION
                //Create a new array of individuals called population. This is then
                //populated in the nested loops below.

                for (int i = 0; i < pop; i++) {
                    //Create a new individual at the start of each initial loop. This individuals
                    //genes are then randomly assigned in the nested loop, either to 1 or 0
                    population[i] = new individual2000();

                    for (int j = 1; j <= N; j++) {

                      
                        double cond = randomdouble(0,1);
                        if(j % 13 == 0){
                            int output = random();
                            cond = (double) output;
                        }
                        population[i].setGenes(j-1, cond);

                    }
                    population[i].setFitness(0);
                }
                System.out.println(Arrays.toString(population[0].genes));
                //This loop assesses the 'fitness' of each individual population. This is measured
                //by the total number of 1's vs 0's. The more 1's, the higher a given individuals fitness
                for (int i = 0; i < pop; i++) {

                    individual2000 rando = population[i];
                    population[i].fitness = getFunked2000(rando, trainingData);
                    initialFT += population[i].getFitness();

                }

                System.out.println("--------------------------------------------------------------------------------------");
                System.out.println("Generation Number " + g + ". The Population size is " + pop + " and the chromosome length is " + N);
                System.out.println("The total fitness of the initial population is: " + initialFT);
                
            } else if (g != 0) {

                for (int k = 0; k < pop; k++) {
                    for (int m = 0; m < N; m++) {
                        population[k].genes[m] = offspring[k].genes[m];
                    }
                    population[k].fitness = offspring[k].fitness;
                }
                System.out.println("--------------------------------------------------------------------------------------");
                System.out.println("Generation Number " + g + ". The Population size is " + pop + " and the chromosome length is " + N);
                // System.out.println("The total fitness of the initial population is: " + initialFT);

            }
            //----------------------------------
            //TOURNAMENT SELECTION

            //This is tournament selection. Two individuals are chosen at near-random to
            // go head to head. The winner, or the individuals with the highest fitness ranking
            // is copied into an offspring array. This is done until the size of the offspring array
            //matches that of the original population array. Previously did this in a function/method
            //but it didn't work so now I'm scared
            for (int i = 0; i < pop; i++) {
                int parent1 = randomRange(0, pop - 1);
                int parent2 = randomRange(0, pop - 1);

                int p1Fitness = population[parent1].getFitness();
                int p2Fitness = population[parent2].getFitness();

                if (p1Fitness >= p2Fitness) {
                    offspring[i] = population[parent1];
                } else {
                    offspring[i] = population[parent2];
                }
            }
            //---------------------------------------------

            //Check the fitness after tournament selection
            for (int i = 0; i < pop; i++) {
                offspring[i].fitness = getFunked2000(offspring[i], trainingData);
                currentFT += offspring[i].getFitness();

            }

            System.out.println("The total fitness of the offspring population after tournament selection is: " + currentFT);

            //------------------------------------------------
            //CROSSOVER
            //
            //Crossing over pairs of individuals; selecting a random point,
            //and swapping the genes of the two individuals after that point
            // ie point = 4, the first 4 genes of each individual stay the same but
            //those thereafter are swapped.
            offspring = crossoverExecute(offspring);

            //--------------------------------
            //MUTATION
            //Each gene, when passed in to the mutation method has a 1/pM chance of
            //mutating. The mutated gene replaces the original gene. pM is set to a value
            //somewhere between the length of the chromosome of an individual (sequence of genes)
            //and the size of the population. Initially, these were both ten.
            for (int x = 0; x < pop; x++) {
                double [] genes = offspring[x].genes;
                //int[] newGenes = new int[genes.length];

                genes = bitwiseMutation(genes);
                for (int y = 0; y < genes.length; y++) {
                    offspring[x].setGenes(y, genes[y]);
                }
            }
            //----------------------------------------------
            //FITNESS REASSESSMENT
            int worstCounter = 0;
            for (int i = 0; i < pop; i++) {
                offspring[i].fitness = getFunked2000(offspring[i], trainingData);
                //Check if the current individual is the fittest.
                if (highestFitness < offspring[i].getFitness()) {
                    highestFitness = offspring[i].getFitness();
                    for (int k = 0; k < N; k++) {
                        fittest.genes[k] = offspring[i].genes[k];
                        if (k == N - 1) {
                            fittest.fitness = offspring[i].fitness;
                        }
                    }

                }
                if(lowestFitness > offspring[i].getFitness()){
                    lowestFitness = offspring[i].getFitness();
                     for (int k = 0; k < N; k++) {
                        worst.genes[k] = offspring[i].genes[k];
                        if (k == N - 1) {
                            worst.fitness = offspring[i].fitness;
                        }
                    }
                     worstCounter = i;
                }
                offspringFT += offspring[i].getFitness();

            }
            averageFitness = offspringFT / pop;
            //System.out.println("");
            System.out.println("The total fitness of the offspring population after crossover and mutation is: " + offspringFT);
            System.out.println("The highest fitness value of any individual in the offspring population is : " + highestFitness);
            System.out.println("The average fitness of the offspring population after crossover and mutation is: " + averageFitness);
            System.out.println("The lowest fitness of the offspring population after crossover and mutation is: " + lowestFitness);
            System.out.println("--------------------------------------------------------------------------------------");
            System.out.println("");
            //Replace the worst candidate in the offspring array with a copy of the best
             for (int k = 0; k < N; k++) {
                        offspring[worstCounter].genes[k] = fittest.getGenes(k);
                        if (k == N - 1) {
                            offspring[worstCounter].fitness = fittest.fitness;
                        }
                    }
            //Write the details of the current generation to diff files
            writeFittest("3", generations, highestFitness, g, pop, N);
            writeAverage("3", generations, averageFitness, g, pop, N);
            writeLowest("3", generations, lowestFitness, g, pop, N);
            //---------------------------------------------------   
        }//End of big for(g=0.. loop
        System.out.println("The highest fitness of any individual in any generation is: \t" + fittest.getFitness() + "\n");
        System.out.println("The fittest individuals array contents : \n");

        
        getFunked2000PRINT(fittest, trainingData);

        System.out.println(numberofNines);
        System.out.println("--------------------------------------------------------------------------------------");
        System.out.println("Running fittest individual ruleset over test data");
     
        double superFit = getFunked2000(fittest, testData);
        double fitnessScore = (superFit / 500) * 100;
        fitnessScore = Math.round(fitnessScore);
        System.out.println("The fittest individual achieved a classification rate of : " + fitnessScore + "%");
        writeFittestScore("3", generations,(int) fitnessScore, 0, pop, N);
       

    }

    /**
     * Reads in the data from the text file into an array that is used
     * throughout the algorithm
     *
     * @param input64 
     */
    public static row2000[] getData() {
        
         row2000[] input2000 = new row2000[2000];
         Scanner sc2000 = new Scanner(classification.class.getResourceAsStream("data3.txt"));
        for (int i = 0; i < 2000; i++) {
            String line = sc2000.nextLine();
            String[] parts = line.split(" ");

            String[] var2000 = Arrays.copyOf(parts, parts.length - 1);
            double[] v2k = new double[6];
            for (int j = 0; j < 6; j++) {
                double temp = Double.parseDouble(var2000[j]);
                v2k[j] = temp;
            }
            input2000[i] = new row2000(v2k, Integer.parseInt(parts[6]));
           // System.out.println(Arrays.toString(input2000[i].var) + " " + input2000[i].predicted);
        }
        return input2000;
    }
    public static row2000[][] getData2000() throws FileNotFoundException {
        row2000[][] data = new row2000[2][];
        data[0] = new row2000[1500];
        data[1] = new row2000[500];
       
       Scanner sc = new Scanner(classification.class.getResourceAsStream("data3.txt"));
        
 
        int i = 0;
        int x = 0;
        int count = 0;
        String line;
        while (sc.hasNextLine()) {
 
            line = sc.nextLine();
            String[] parts = line.split(" ");
 
            String[] var2000 = Arrays.copyOf(parts, parts.length - 1);
            double[] v2k = new double[6];
 
            for (int j = 0; j < 6; j++) {
                double temp = Double.parseDouble(var2000[j]);
                v2k[j] = temp;
            }
 
            if (count % 4 == 0) {
                data[1][x++] = new row2000(v2k, Integer.parseInt(parts[6]));
            } else {
               data[0][i++] = new row2000(v2k, Integer.parseInt(parts[6]));
            }
 
            count++;
        }
 
        return data;
    }

    //MUTATION FUNCTIONS
    public static double[] bitwiseMutation(double [] genes) {

        //the luck variable is used as the probability,
        //it will be a number between 0 - 10, and if that number is 7
        //the gene at position y is mutated. The value of luck changes
        //with each iteration.
        int length = genes.length;

        double[] mutantGenes = new double [length];

        for (int y = 1; y <= length; y++) {
            int luck = randomRange(0, 40);
            if (luck == 1) {
                //Mutate(invert) the genes if luck is a lady

                if (y % 13 != 0) {
                    int luck3 = random();
                    if (luck3 == 1) {
                        mutantGenes[y - 1] = genes[y-1] + 0.1;
                        numberofNines++;
                    } else {
                        mutantGenes[y - 1] = genes[y-1] - 0.1;
                    }
                } else if (y % 13 == 0) {
                    if (genes[y - 1] == 0) {
                        mutantGenes[y - 1] = 1;
                    } else if (genes[y - 1] == 1) {
                        mutantGenes[y-1] = 0;

                    }

                }

               
            } //if luck is not a lady, the genes don't change, so assign
            //the original gene value at position y  to the 
            // corresponding position in the return array.
            else {
                mutantGenes[y - 1] = genes[y - 1];
            }
        }
        return mutantGenes;

    }

    //CROSSOVER FUNCTIONS
    /**
     * Takes in two individuals genes and crosses them over
     *
     * @param parent1 First array of genes
     * @param parent2 Second array of genes
     * @return returns the crossed over array of genes
     */
    private static double[][] crossover(double[] parent1, double[] parent2) {
        double[][] theChildren = new double[2][N];
        int crossPoint = randomRange(1, N - 1);

        double[] temp = parent1.clone();
        for (int i = crossPoint; i < N; i++) {
            parent1[i] = parent2[i];
            parent2[i] = temp[i];
        }

        theChildren[0] = parent1;
        theChildren[1] = parent2;

        return theChildren;
    }

    /**
     * Takes in an array of individuals and crosses over the genes of individual
     * i and i + 1.
     *
     * @param offspring input population
     * @return Returns an array of newly crossed over individuals.
     */
    public static individual2000[] crossoverExecute(individual2000[] offspring) {
        individual2000[] crossy = new individual2000[pop];
        for (int i = 0; i < pop; i++) {
            crossy[i] = new individual2000();
        }

        for (int i = 0; i < pop; i += 2) {

            //Retrieve arrays of genes so as to pass them into the crossover method
            double[] p0 = offspring[i].genes;
            double[] p1 = offspring[i + 1].genes;

            double[][] kids = crossover(p0, p1);

            //The tails have been swapped, new children formed
            crossy[i].genes = kids[0];
            crossy[i + 1].genes = kids[1];

        }
        return crossy;
    }

    //RANDOM GENERATORS   
    /**
     * Generates a random number within the given range.
     *
     * @param min Lower range.
     * @param max Upper range.
     * @return Returns random number between min and max.
     */
    private static int randomRange(int min, int max) {
        
        
       Random r = new Random();
       return r.nextInt(max - min) + min;
        
        
    }

     private static double randomdouble(int min, int max) {
        
        
       Random r = new Random();
       double random = min + r.nextDouble() * (max - min);
       return random;
        
        
    }
    /**
     * Generates a 0 or a 1 randomly
     *
     * @return o or 1
     */
    public static int random() {
        if (Math.random() < 0.5) {
            return 1;
        }
        return 0;
    }

    //GET FUNKED
    private static int getFunked2000(individual2000 rando, row2000[] inputData2000) {
        int sFitness = 0;
        int g = 0;
        individual2000 nrando = rando;
        row2000[] rules = new row2000[indoRules];

        //feed in the genes to make some rules
        for (int i = 0; i < indoRules; i++) {
            double[] tempArray = new double[12];
            int pv = 0;
            for (int j = 0; j < 13; j++) {

                if (j == 12) {
                    pv =  (int) nrando.genes[g++];

                } else {
                    tempArray[j] = 
                            nrando.genes[g++];

                }
            }
            rules[i] = new row2000(tempArray, pv);
        }

        //print loop
        //To test if the rule array has been populated correctly from the individual
        /*  for(int i = 0;i < rules.length;i++){
          System.out.println(Arrays.toString(rules[i].var) + " " + rules[i].predicted);
      }*/
        for (int i = 0; i < inputData2000.length; i++) {
            for (int j = 0; j < indoRules; j++) {
                if (compareRules(rules[j].var, inputData2000[i].var)) {//if the contents of each array i.e. the rules match
                    if (inputData2000[i].getPredicted() == rules[j].getPredicted()) {
                        sFitness++;
                    }
                    break;
                }
            }
        }

        return sFitness;
    }

     private static int getFunked2000PRINT(individual2000 rando, row2000[] inputData2000) {
        int sFitness = 0;
        int g = 0;
        individual2000 nrando = rando;
        row2000[] rules = new row2000[indoRules];

        //feed in the genes to make some rules
        for (int i = 0; i < indoRules; i++) {
            double[] tempArray = new double[12];
            int pv = 0;
            for (int j = 0; j < 13; j++) {

                if (j == 12) {
                    pv =  (int) nrando.genes[g++];

                } else {
                    tempArray[j] = nrando.genes[g++];

                }
            }
            rules[i] = new row2000(tempArray, pv);
        }

        //print loop
        //To test if the rule array has been populated correctly from the individual
        /*  for(int i = 0;i < rules.length;i++){
          System.out.println(Arrays.toString(rules[i].var) + " " + rules[i].predicted);
      }*/
        for (int i = 0; i < inputData2000.length; i++) {
            for (int j = 0; j < indoRules; j++) {
                if (compareRules(rules[j].var, inputData2000[i].var)) {//if the contents of each array i.e. the rules match
                    if (inputData2000[i].getPredicted() == rules[j].getPredicted()) {
                        sFitness++;
                    }
                    break;
                }
            }
        }
         for (int i = 0; i < 10; i++) {
            System.out.println(Arrays.toString(rules[i].var) + " " + rules[i].predicted);

        }

        return sFitness;
    }
    
   

    public static boolean match(char[] a, char[] b) {
        int length = a.length;
        int count = 0;

        for (int i = 0; i < length; i++) {
            if (a[i] == b[i] || b[i] == '2') {
                count++;
            }
        }

        return count == 6;
    }

    /**
     * Checks to see if a rule generate by the algorithm matches with a rule
     * stored in the data files
     *
     * @param a Rule generated by the GA.
     * @param b Rule stored in the data file.
     * @return Returns true if all 6 items in the arrays match with each other.
     */
    public static boolean compareRules(double[] a, double[] b) {

        int length = a.length;
        int count = 0;
        int inputCounter = 0;
        for (int i = 0; i < 12; i+=2) {
            double c1 = a[i];
            double c2 = a[i+1];
            double find = b[inputCounter];
            
            if(c1 > c2){
                double temp = c1;
                c1 = c2;
                c2 = temp;
            }
            
            if(find > c1 && find < c2){
                count++;
            }
            inputCounter++;
        }

        //Checking for a '2' as '2' is a wild card.
        /*for (int i = 0; i < length; i++) {
            if (a[i] == b[i] || a[i] == 2) {
                count++;
            }
        }*/

        //Returns true if all 6 items match, false otherwise
        return count == 6;
    }
    
         public static void writeFittest(String file, int numberOfGenerations, int fittestIndividual, int currentGenNumber, int popSize, int chromosomeSize) throws IOException {
        String suffix = numberOfGenerations + "-" + popSize + "-" + chromosomeSize + ".csv";
        
        if("1".equals(file)){
            
            file = enhance + "data32-HFIT" + suffix;
        }
        else if("2".equals(file)){
            if(currentGenNumber == generations - 1) {
                file = enhance + "data64-FINALHFIT" + suffix;
            }
            else{
            file = enhance + "data64-HFIT" + suffix;
            }
        }
        else if("3".equals(file)){
            if(currentGenNumber == generations - 1) {
                file = enhance + "data2000-FINALHFIT" + suffix;
            }
            else{
            file = enhance + "data2000-HFIT" + suffix;
            }
        }
 
        String str = String.valueOf(currentGenNumber) + "," + String.valueOf(fittestIndividual);
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, true))) {
            writer.append(str + "\n");
        }
    }
         
         public static void writeFittestScore(String file, int numberOfGenerations, int fittestIndividual, int currentGenNumber, int popSize, int chromosomeSize) throws IOException {
        String suffix = numberOfGenerations + "-" + popSize + "-" + chromosomeSize + ".csv";
        
        if("1".equals(file)){
            
            file = enhance + "data32-HFIT" + suffix;
        }
        else if("2".equals(file)){
            if(currentGenNumber == generations - 1) {
                file = enhance + "data64-FINALHFIT" + suffix;
            }
            else{
            file = enhance + "data64-HFIT" + suffix;
            }
        }
        else if("3".equals(file)){
           
            file = enhance + "2000TESTSCORE" + suffix;
            
        }
 
        String str = String.valueOf(currentGenNumber) + "," + String.valueOf(fittestIndividual);
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, true))) {
            writer.append(str + "\n");
        }
    }
       public static void writeAverage(String file, int numberOfGenerations, int averageFitness, int currentGenNumber, int popSize, int chromosomeSize) throws IOException {
        String suffix = numberOfGenerations + "-" + popSize + "-" + chromosomeSize + ".csv";
        
        if("1".equals(file)){
            file = enhance + "data32-AVFIT" + suffix;
        }
        else if("2".equals(file)){
            file = enhance + "data64-AVFIT" + suffix;
        }
        else if("3".equals(file)){
            file = enhance + "data2000-AVFIT" + suffix;
        }
 
        String str = String.valueOf(currentGenNumber) + "," + String.valueOf(averageFitness);
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, true))) {
            writer.append(str + "\n");
        }
    }
        public static void writeLowest(String file, int numberOfGenerations, int lowestFitness, int currentGenNumber, int popSize, int chromosomeSize) throws IOException {
        String suffix = numberOfGenerations + "-" + popSize + "-" + chromosomeSize + ".csv";
        
        if("1".equals(file)){
            file = enhance + "data32-HFIT" + suffix;
        }
        else if("2".equals(file)){
            file = enhance + "data64-HFIT" + suffix;
        }
        else if("3".equals(file)){
            file = enhance + "data2000-LOFIT" + suffix;
        }
 
        String str = String.valueOf(currentGenNumber) + "," + String.valueOf(lowestFitness);
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, true))) {
            writer.append(str + "\n");
        }
    }
      
}
  